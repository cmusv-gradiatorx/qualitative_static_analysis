Milestone III

1) Functional scope

As part of this milestone, you need to develop the remaining functionalities of the system (apart from e-mail notifications) and integrate them (ensure they interact with each other as expected). Like last time, functionalities need to be implemented end-to-end (including side effects), along with data types that are used as part of them as well as some unit tests (team of 4). The following functionalities are in scope:
* Real-time trading
* Orders management
* P&L calculation (teams of 4)
* Annualized return metric calculation (adaptations of hard-coded values)

1.1 Real-time trading
Please refer to the project specification document (https://canvas.cmu.edu/courses/41846/files/11646688) (section Real-time trading algorithm) for functional requirements of this feature. Additionally, the system needs to handle input from the user to initiate and stop trading on demand - these correspond to dedicated REST API endpoints. The functionality needs to integrate with real-time data management (market data cache included) and trading parameters management developed in Milestone II.
Given the indeterministic nature of real-time market data, for testing purposes you can use a dedicated mock API (wss://one8656-livedata.onrender.com/). It generates a pre-determined set of quotes that contain arbitrage opportunities for a specific set of trading parameters (see below). This endpoint doesn't account for subscription parameters provided - it will always generate the same market data quotes.
* There is no need to provide an API key.
* Market data will be emitted one value at a time, encompassed in an array (same format as Polygon’s).
* Upon establishing a connection, a message will be broadcasted: [{ "ev":"status", "status":"connected", "message": "Connected Successfully" }]
* The first market data message will contain the “ev” field, which is the identifier to distinguish the type of message.
* Please see below an example of two successive market data updates.
  * [{"ev":"XQ","pair":"SOL-USD","x":23,"bp":28.05,"bs":19.98,"ap":28.07,"as":20.12,"t":1701197108733}]
  * [{"pair":"SOL-USD","ev":"XQ","x":6,"bp":28.05,"bs":21.22,"ap":28.06,"as":35,"t":1701197108760}]

You should use the following Trading Strategy parameters to seize arbitrage opportunities in the simulated real-time feed: 
* number of crypto currencies to track: 5
* minimal price spread value: 0,05
* minimal transaction profit: 5
* maximal transaction value: 2000
* maximal trading value: 5000

After 7 market data updates, the following orders should be placed:
SOL-USD, 6 (BitStamp) Buy, 28.06, 35.00
SOL-USD, 23 (Kraken) Sell, 28.22, 35.00

After 12 market data updates, the following order should be placed:
DOT-USD, 2 (BitFinex) Buy, 5.2529, 150.0
DOT-USD, 6 (BitStamp) Sell, 5.314, 150

1.2 Orders management
Once an arbitrage opportunity is identified and meets the trading strategy constraints, buy and sell orders should be emitted to corresponding crypto currency exchanges and their lifecycle managed in the system. Order placing should be followed by an order status retrieval automatically after a delay of 5s.
Many of the exchanges offer APIs both as REST and websockets-accessible. While in an industrial set up the latter would be favoured (for it's truly real time nature), in the context of the project, REST APIs should be used. This approach will facilitate testing of the platform with mock responses (as part of the final delivery).
To ensure a uniform format of the responses handled, your solution needs to handle specific REST API endpoints for all of the crypto currencies exchanges as per the list below. You do not need to register or authenticate with the exchanges - as part of Milestone IV mock endpoints will be used for testing.
Bitfinex:
* Submit order: https://docs.bitfinex.com/reference/rest-auth-submit-order (https://docs.bitfinex.com/reference/rest-auth-submit-order)
* Retrieve order trades: https://docs.bitfinex.com/reference/rest-auth-order-trades (https://docs.bitfinex.com/reference/rest-auth-ordertrades)
Kraken:
* Submit order: https://docs.kraken.com/rest/#tag/Trading/operation/addOrder (https://docs.kraken.com/rest/#tag/Trading/operation/addOrder)
* Query order information https://docs.kraken.com/rest/#tag/Account-Data/operation/getOrdersInfo (https://docs.kraken.com/rest/#tag/Account-Data/operation/getOrdersInfo)
Bitstamp:
* Emit buy order: https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketBuyOrder (https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketBuyOrder)
* Emit sell order: https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketSellOrder (https://www.bitstamp.net/api/#tag/Orders/operation/OpenMarketSellOrder)
* Retrieve order status: https://www.bitstamp.net/api/#tag/Orders/operation/GetOrderStatus (https://www.bitstamp.net/api/#tag/Orders/operation/GetOrderStatus)

Data persistence needs to take place as per the project specification document (https://canvas.cmu.edu/courses/41846/files/11646688), Real time trading algorithm section.
E-mail notifications are part of the next milestone.

1.3 P&L calculation (teams of 4)
Please refer to the project specification document (https://canvas.cmu.edu/courses/41846/files/11646688), for functional requirements of this feature. The system needs to handle input from the user to set and update P&L threshold and launch P&L calculation on demand - these correspond to dedicated REST API endpoints.
E-mail notifications are part of the next milestone.

1.4 Annualized return metric calculation refactoring (teams of 4)
Please update the existing implementation to remove hard-coded values used in Milestone II:
* the start date of trading activity - this should correspond to the "start trading" action in 1.1
* cumulative P&L value - this needs to be propagated from 1.3.

2) Error handling
Error handling mechanism should be implemented for all functions containing side effects in the system.
The solution should employ railroad-oriented programming for error handling and use a variety of adapter/converter functions depending on the need (refer to lecture 12 for more details).

3) Unit tests
Some area of the solution (see list below) need to be covered with unit tests - a handful of tests per functionality is expected. Given that each team structures the workflows as they please, unit tests should match the granularity of your workflow steps.
* P&L calculation

Technical Debt and next steps

During this milestone, you will focus on extensive integration work, both within your existing code and with external systems. Please keep in mind that, as part of the evaluation, a code review will take place (code will not be executed). It might reveal areas where your implementation introduces functional issues or requires improvements. However, when integrating different parts of the system, there might be other issues which will be classified as "Technical Debt."
Technical Debt refers to the outstanding work or potential problems that need to be addressed in the future milestone to improve code quality, maintainability, and functionality. This includes, but is not limited to:
* Incomplete or suboptimal integration points within your code.
* Potential bugs or performance issues introduced during the integration.
* External system integration issues.
* Any other technical shortcomings identified by the development team.

You will need to prioritize addressing this technical debt in the next milestone to ensure the robustness and reliability of your projects. This approach ensures continuous improvement and helps maintain high standards of code quality throughout the development process.

Submission
To verify completeness of your implementation, please prepare a document (README/pdf/doc/other) that lists the functionalities of your solution (please use the same structure as in the milestone description) and the source code file where they can be found.
Include any known issues (Technical Debt) that the team will address in Milestone IV.

Evaluation
The solution will be evaluated among three dimensions: completeness (6), respect of Functional Programming and DDD principles (2) and Code Clarity and Readability (2). 10 points in total. Your code will not be executed and assessment will be based on a peer review (functional correctness issues are treated as Technical Debt to be addressed in Milestone IV)
The source code needs to be aligned with Functional Programming and Domain-Driven Design principles, which implies that (the list is nonexhaustive): 
* The solution domain model is implemented using algebraic type system, which: 
  * uses ubiquitous language (devoid of technical jargon and understandable to business), 
  * employs a variety of constructs (e.g. simple type, discriminated union, option type, generics) to ensure that data follows business rules
* Codebase is well-commented, modular and has consistent naming conventions and logical structure.
* Codebase respects the Onion Architecture correctly.
* Error handling is implemented with the Railroad-Oriented Programming approach.
* System handles scenarios like unexpected API responses, network failures, or data format discrepancies with appropriate error messages.
* Each business logic function should work on immutable data.
* Dependencies are managed explicitly as function parameters.
* Control flow expressions are avoided, and pattern matching/collections are used instead. 
* OOP constructs of F# are not used.
