[
    {
      "criterion_name": "Real-time Trading System",
      "max_points": 2.0,
      "specific_prompt": "Evaluate the 'Real-time Trading System' component. This involves the implementation and integration of real-time trading functionalities.\n\n**Assessment Guidelines:**\n- **Excellent (1.8-2.0 points)**: Complete real-time trading with proper WebSocket integration, arbitrage detection, order management, stop/start controls, and user-defined trading parameters.\n- **Good (1.4-1.7 points)**: Most trading functionality implemented with minor gaps in integration or parameter handling.\n- **Satisfactory (1.0-1.3 points)**: Basic trading logic present but incomplete integration or missing key components.\n- **Poor (0.0-0.9 points)**: Missing or severely incomplete trading implementation.\n\nFocus on: WebSocket integration, arbitrage detection logic, order placement/management mechanisms, control interfaces (stop/start), and how user-defined parameters influence trading."
    },
    {
      "criterion_name": "Orders Management",
      "max_points": 1.5,
      "specific_prompt": "Evaluate the 'Orders Management' system.\n\n**Assessment Guidelines:**\n- **Excellent (1.3-1.5 points)**: Comprehensive order lifecycle management with status tracking (e.g., pending, filled, cancelled), handling of partial fills, database persistence for orders, and proper handling of buy/sell order matching logic.\n- **Good (1.0-1.2 points)**: Good order management with minor issues in edge cases (e.g., rare fill scenarios) or less robust status tracking.\n- **Satisfactory (0.7-0.9 points)**: Basic order handling present but missing some critical lifecycle management features (e.g., no partial fill handling, limited status tracking).\n- **Poor (0.0-0.6 points)**: Incomplete or incorrect order management, significant features missing or non-functional.\n\nFocus on: How orders are created, tracked through their lifecycle, stored, and how different fill scenarios (full, partial) are handled."
    },
    {
      "criterion_name": "P&L Calculation",
      "max_points": 1.5,
      "specific_prompt": "Evaluate the 'P&L Calculation' functionality.\n\n**Assessment Guidelines:**\n- **Excellent (1.3-1.5 points)**: Accurate Profit & Loss (P&L) calculation for all relevant order types and trading activities. Includes proper profit/loss tracking mechanisms, threshold notifications (if applicable), and capability for historical P&L retrieval.\n- **Good (1.0-1.2 points)**: Mostly correct P&L calculations with minor inaccuracies in specific scenarios or missing advanced features like threshold notifications.\n- **Satisfactory (0.7-0.9 points)**: Basic P&L implementation is present but may have incomplete or noticeably inaccurate calculations in common scenarios.\n- **Poor (0.0-0.6 points)**: Missing or fundamentally incorrect P&L calculation logic.\n\nFocus on: Accuracy of P&L formulas, tracking of costs and revenues, handling of different trade outcomes, and data retrieval for P&L reporting."
    },
    {
      "criterion_name": "Annualized Return Metric Calculation (For 4-person teams only)",
      "max_points": 0.5,
      "specific_prompt": "Evaluate the 'Annualized Return Metric Calculation'. *Note: This criterion is applicable for 4-person teams only. If not a 4-person team, or if not implemented, score appropriately based on expectation.*\n\n**Assessment Guidelines:**\n- **Excellent (0.45-0.5 points)**: Correct annualized return calculation demonstrating proper understanding and implementation of the formula, including accurate handling of the time period involved.\n- **Good (0.35-0.44 points)**: Mostly correct implementation with minor issues in formula application or time period handling.\n- **Satisfactory (0.25-0.34 points)**: Basic implementation attempt but contains calculation errors or significant misunderstandings of the concept.\n- **Poor (0.0-0.24 points)**: Missing, fundamentally incorrect, or non-applicable implementation.\n\nFocus on: The formula used, its correct application to the project's data, and the handling of time periods for annualization."
    },
    {
      "criterion_name": "System Integration & End-to-End Functionality",
      "max_points": 0.5,
      "specific_prompt": "Evaluate the 'System Integration & End-to-End Functionality'. This assesses how well all components of the ArbitrageGainer system work together.\n\n**Assessment Guidelines:**\n- **Excellent (0.45-0.5 points)**: All components (real-time trading, order management, P&L calculation, parameter management) work together seamlessly with proper and logical data flow between them.\n- **Good (0.35-0.44 points)**: Good integration overall, with only minor issues in component interaction or data flow.\n- **Satisfactory (0.25-0.34 points)**: Basic integration is present, but some components may feel disconnected, or data flow between them is clunky or inefficient.\n- **Poor (0.0-0.24 points)**: Poor or missing integration between system components; system does not function as a cohesive whole.\n\nFocus on: The interaction between modules. Does data from parameter management correctly influence trading? Does trading activity correctly feed into order management and P&L calculations? Is the overall workflow smooth?"
    },
    {
      "criterion_name": "Functional Programming Principles",
      "max_points": 1.0,
      "specific_prompt": "Evaluate the adherence to core Functional Programming (FP) principles throughout the codebase.\n\n**Key FP practices to assess:**\n- **Immutability**: Are data structures treated as immutable? Do transformations create new instances rather than modifying existing ones?\n- **Pure functions**: Is business logic primarily implemented using functions that have no side effects and are deterministic (given the same input, always return the same output)?\n- **Function composition**: Are complex operations built by composing smaller, reusable functions?\n- **Higher-order functions**: Is there effective use of functions like map, filter, fold (reduce), and are custom higher-order functions used where appropriate?\n- **Error handling**: Is there consistent use of patterns like Result types (or similar, e.g., Either) and railroad-oriented programming for managing errors and exceptional flows?\n- **Avoidance of imperative constructs**: Is there a clear avoidance of loops (for, while), mutable variables, and explicit state changes in core logic? Are object-oriented patterns (classes with mutable state and methods that mutate it) avoided in favor of functional approaches?\n- **Side effect management**: Is there a clear separation between pure functions (business logic) and impure functions (those performing I/O, interacting with external systems, etc.)?\n\n**Scoring:**\n- **Excellent (0.9-1.0 points)**: Consistent and masterful application of functional approach throughout the relevant parts of the codebase. Demonstrates deep understanding and skillful use of FP concepts. Comprehensive and robust error handling using FP patterns.\n- **Good (0.7-0.8 points)**: Strong adherence to functional programming principles with only occasional, minor lapses. Good use of most FP concepts listed.\n- **Satisfactory (0.5-0.6 points)**: A mixed approach. Some functional principles are applied, but usage is inconsistent, or some key FP concepts are misunderstood or underutilized. May still contain significant imperative sections.\n- **Poor (0.0-0.4 points)**: Predominantly imperative approach. Little to no evidence of applying functional programming principles correctly, or fundamental misunderstandings of FP concepts are apparent."
    },
    {
      "criterion_name": "Domain-Driven Design Principles",
      "max_points": 1.0,
      "specific_prompt": "Evaluate the implementation of Domain-Driven Design (DDD) principles, focusing on how well the software model aligns with the arbitrage trading domain.\n\n**Key DDD aspects to assess:**\n- **Ubiquitous language**: Is there evidence of a clear, business-focused language (terms like Order, ArbitrageOpportunity, Trade, Exchange, Pair) used consistently in naming types, functions, modules, and variables?\n- **Algebraic type system (or equivalent rich types)**: How effectively are types (e.g., discriminated unions/enums with associated data, record types/structs, option types/nullable types) used to model domain concepts precisely and make illegal states unrepresentable?\n- **Business rules in types**: Are domain constraints and business rules effectively enforced or represented through the type system itself?\n- **Domain modeling**: Are there appropriate and well-defined entities and value objects for core trading concepts (e.g., Order, ArbitrageOpportunity, TradingParameters, PnLReport)?\n- **Architectural layering (e.g., Onion Architecture)**: Is there a clear separation between domain logic, application services, and infrastructure concerns (e.g., database access, API calls)?\n- **Dependency direction**: Do dependencies generally point inward, with the domain core having minimal dependencies on outer layers like infrastructure?\n- **Domain purity**: Is the core domain logic kept free from external infrastructure concerns (e.g., no direct database calls or API client logic within pure domain functions)?\n\n**Scoring:**\n- **Excellent (0.9-1.0 points)**: Rich and expressive domain model with comprehensive use of algebraic types (or equivalent). Perfect or near-perfect architectural layering adhering to DDD principles (like Onion Architecture). Strong and consistent use of ubiquitous language.\n- **Good (0.7-0.8 points)**: Good domain modeling with appropriate types. Architectural layers are mostly clear and well-defined. Ubiquitous language is generally well-applied.\n- **Satisfactory (0.5-0.6 points)**: Basic domain modeling is present, but type usage might be incomplete or not fully leveraged. Layer separation might be unclear or inconsistent in places.\n- **Poor (0.0-0.4 points)**: Poor or superficial domain modeling. Limited use of types to represent domain concepts. Architectural layers are confused, or DDD principles are largely absent."
    },
    {
      "criterion_name": "Code Organization & Structure",
      "max_points": 1.0,
      "specific_prompt": "Evaluate the overall organization and structure of the codebase.\n\n**Key aspects to assess:**\n- **Module structure**: Is the code organized into modules that align with domain boundaries or logical components (e.g., `Trading`, `Orders`, `Pnl`, `Exchanges`, `CoreDomain`)?\n- **Logical code organization**: Within modules, is code organized logically, perhaps following functional programming patterns (e.g., types defined first, then functions operating on those types)?\n- **Naming conventions**: Are naming conventions consistent and do they use the ubiquitous language of the domain?\n- **Function granularity**: Are functions generally small, focused, and adhere to the single responsibility principle?\n- **File and folder structure**: Is the file and folder structure clear, intuitive, and does it support the module organization?\n\n**Scoring:**\n- **Excellent (0.9-1.0 points)**: Exceptionally well-organized code. Module structure is very clear and logical. Naming is consistent and highly descriptive. Functions are well-defined and appropriately granular.\n- **Good (0.7-0.8 points)**: Well-organized code with a good overall structure. Naming is mostly clear and consistent. Minor areas for improvement in organization or granularity may exist.\n- **Satisfactory (0.5-0.6 points)**: Adequate organization, but there may be some inconsistencies in structure, naming, or function granularity that make the code harder to navigate or understand.\n- **Poor (0.0-0.4 points)**: Poor organization. The code structure is confusing, difficult to follow, or inconsistent. Naming may be unhelpful or misleading."
    },
    {
      "criterion_name": "Documentation, Comments & Testing",
      "max_points": 1.0,
      "specific_prompt": "Evaluate the quality and extent of documentation, comments, and testing within the project.\n\n**Key aspects to assess:**\n- **Comments**: Is the code well-commented where necessary? Are there meaningful explanations for complex business logic, non-obvious decisions, or tricky sections of code?\n- **Documentation**: Is there clear module-level documentation? Are function signatures clear and, where appropriate, accompanied by documentation explaining their purpose, parameters, and return values (e.g., using docstrings or standard commenting styles)?\n- **Unit tests**: Are there meaningful unit tests, especially for critical business logic such as P&L calculations, arbitrage detection, and order processing logic? Do tests cover a range of scenarios, including edge cases?\n- **Code readability**: Does the code strive to be self-documenting? Is it generally easy to read and understand, even without extensive comments, due to good naming and structure?\n- **Test organization**: Are test cases well-structured and organized, making it easy to understand what is being tested and to maintain the tests?\n\n**Scoring:**\n- **Excellent (0.9-1.0 points)**: Comprehensive and high-quality documentation and comments. Thorough and meaningful unit tests cover critical functionality and edge cases. Code is highly readable.\n- **Good (0.7-0.8 points)**: Good documentation and testing practices with only minor gaps. Most critical areas are covered.\n- **Satisfactory (0.5-0.6 points)**: Basic documentation and some testing are present, but coverage is incomplete or tests are superficial. Comments may be sparse or not very helpful.\n- **Poor (0.0-0.4 points)**: Poor or missing documentation, comments, and/or tests. Significant parts of the codebase lack explanation or validation."
    }
  ]