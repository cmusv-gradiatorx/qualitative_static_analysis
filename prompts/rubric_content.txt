1) Functional scope
As part of this milestone, you need to develop the remaining functionalities of the system (apart from e-mail notifications) and integrate them (ensure
they interact with each other as expected). Like last time, functionalities need to be implemented end-to-end (including side effects), along with data
types that are used as part of them as well as some unit tests (team of 4). The following functionalities are in scope:
Real-time trading
Orders management
P&L calculation (teams of 4)
Annualized return metric calculation (adaptations of hard-coded values)
1.1 Real-time trading
Please refer to the project specification document (https://canvas.cmu.edu/courses/41846/files/11646688) (section Real-time trading algorithm) for
functional requirements of this feature. Additionally, the system needs to handle input from the user to initiate and stop trading on demand - these
correspond to dedicated REST API endpoints. The functionality needs to integrate with real-time data management (market data cache included) and
trading parameters management developed in Milestone II.

Given the indeterministic nature of real-time market data, for testing purposes you can use a dedicated mock API (wss://one8656-live-
data.onrender.com/). It generates a pre-determined set of quotes that contain arbitrage opportunities for a specific set of trading parameters (see

below). This endpoint doesn't account for subscription parameters provided - it will always generate the same market data quotes.
There is no need to provide an API key.
Market data will be emitted one value at a time, encompassed in an array (same format as Polygonâ€™s).

2) Error handling
Error handling mechanism should be implemented for all functions containing side effects in the system.
The solution should employ railroad-oriented programming for error handling and use a variety of adapter/converter functions depending on the need
(refer to lecture 12 for more details).
3) Unit tests
Some area of the solution (see list below) need to be covered with unit tests - a handful of tests per functionality is expected. Given that each team
structures the workflows as they please, unit tests should match the granularity of your workflow steps.
P&L calculation

Technical Debt and next steps
During this milestone, you will focus on extensive integration work, both within your existing code and with external systems. Please keep in mind
that, as part of the evaluation, a code review will take place (code will not be executed). It might reveal areas where your implementation introduces
functional issues or requires improvements. However, when integrating different parts of the system, there might be other issues which will be
classified as "Technical Debt."
Technical Debt refers to the outstanding work or potential problems that need to be addressed in the future milestone to improve code quality,
maintainability, and functionality. This includes, but is not limited to:
4/21/25, 2:23 PM Milestone III

https://canvas.cmu.edu/courses/41846/assignments/729630 2/3

Points
Submitting
10
a website url or a file upload

Due For Available from Until
Nov 24, 2024 Everyone - -
Incomplete or suboptimal integration points within your code.
Potential bugs or performance issues introduced during the integration.
External system integration issues.
Any other technical shortcomings identified by the development team.
You will need to prioritize addressing this technical debt in the next milestone to ensure the robustness and reliability of your projects. This approach
ensures continuous improvement and helps maintain high standards of code quality throughout the development process.

Submission
To verify completeness of your implementation, please prepare a document (README/pdf/doc/other) that lists the functionalities of your solution
(please use the same structure as in the milestone description) and the source code file where they can be found.
Include any known issues (Technical Debt) that the team will address in Milestone IV.

Evaluation
The solution will be evaluated among three dimensions: completeness (6), respect of Functional Programming and DDD principles (2) and Code
Clarity and Readability (2). Your code will not be executed and assessment will be based on a peer review (functional correctness issues are treated
as Technical Debt to be addressed in Milestone IV)

The source code needs to be aligned with Functional Programming and Domain-Driven Design principles, which implies that (the list is non-
exhaustive):

The solution domain model is implemented using algebraic type system, which:
uses ubiquitous language (devoid of technical jargon and understandable to business),
employs a variety of constructs (e.g. simple type, discriminated union, option type, generics) to ensure that data follows business rules
Codebase is well-commented, modular and has consistent naming conventions and logical structure.
Codebase respects the Onion Architecture correctly.
Error handling is implemented with the Railroad-Oriented Programming approach.
System handles scenarios like unexpected API responses, network failures, or data format discrepancies with appropriate error messages.
Each business logic function should work on immutable data.
Dependencies are managed explicitly as function parameters.
Control flow expressions are avoided, and pattern matching/collections are used instead.
OOP constructs of F# are not used.